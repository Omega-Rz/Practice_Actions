
name: Name of the workflow else relative path

#on: [push, workflow_dispatch]
#This event will only trigger a workflow run if the workflow file exists on the default branch.
on: 
  push:
    branches: 
      - main
      - '!feature/*' #This will exclude all branches that start with feature/
    branches-ignore: 
      - 'feature/**' #This will ignore all branches that start with feature/
      - 'feature/*' #This will ignore all branches that start with feature
# /** vs /*
# /** will match all branches that start with feature/ and any sub-branches, such as feature/branch1, feature/branch2, etc.
# /* will match only branches that start with feature/ and not any sub-branches, such as feature/branch1, feature/branc
    paths-ignore: 
      - 'README.md' #This will ignore the README.md file in the root of the repository.
  workflow_dispatch:
  pull_request:
    types: 
      - opened
      - synchronize
      - reopened
      - closed

    branches: 
      - main
      - '!feature/*' #This will exclude all branches that start with feature/
    paths-ignore: 
      - 'README.md' #This will ignore the README.md file in the root of the repository.

concurrency:
  group: workflow-concepts
  #This will cancel any in-progress runs of this workflow if a new run is triggered.
  #This is useful to prevent multiple runs of the same workflow from running at the same time
  #and consuming resources unnecessarily.
  #For example, if you push multiple commits in quick succession, only the latest commit will trigger a run.
  #This is useful for workflows that are triggered by push events, such as CI/CD workflows.
  #If you want to allow multiple runs of the same workflow to run at the same time,
  #you can remove this concurrency setting or set `cancel-in-progress` to false.
  #It work across branches as well.
  #It work across different workflows as well in same branch or repo.
  cancel-in-progress: true
run-name: Installer test with ${{ github.event_name }} event
#This will set the name of the workflow run to "Installer test with push event" or
env:
  WORKFLOW_LEVEL: workflow
  JOB_LEVEL_VAR: job1
  STEP_LEVEL_VAR: step2
jobs:
  first_job:
    runs-on: ubuntu-latest
    permissions:
     contents: read
    timeout-minutes: 1
    #This will set the timeout for the entire job to 1 minute.
    #If any step in the job takes longer than 1 minute, the job will be cancelled.
    #You can also set a timeout for individual steps using the `timeout-minutes`
    #parameter in the step definition.
    #Even if a step has timeout-minutes: 2, it cannot overrule the jobâ€™s 1-minute limit.
    steps:
        - name: Checkout Repo
          uses: actions/checkout@v4
          with:
            path: core
            fetch-depth: 0

        - name: Just Listing with multiline
          run: |
            echo "Just Echoing"
            ls -ltra core
            echo "------------"
            ls ../
            echo ${{ env.WORKFLOW_LEVEL }}
            echo ${{ env.JOB_LEVEL_VAR }}
            echo ${{ env.STEP_LEVEL_VAR }}
            sleep 1
            #Default timeout for a step is 6 hours, you can change it to 1 minute
        - name: install and run figlet
          run: | 
           chmod +x ./core/scripts/installer.sh
           ./core/scripts/installer.sh ${{ secrets.password1 }}
        - name: Upload Artifact
          uses: actions/upload-artifact@v4
          with:
            name: Piglet
            path: abc.txt

  download_artifact:
        runs-on: ubuntu-latest
        needs: first_job
        if: github.ref == 'refs/heads/main' #This will run the job only if the push is to the main branch
        #This will run the job only if the first_job is successful.
        #This is useful for workflows that have multiple jobs and you want to run a job only
        #if a previous job is successful.
        #You can also use `if: success()` to run the job only if all previous jobs are successful.
        #You can also use `if: failure()` to run the job only if a previous job has failed.
        #You can also use `if: always()` to run the job regardless of the success or failure of previous jobs.
        #You can also use `if: cancelled()` to run the job only if a previous job was cancelled.
        env:
          JOB_LEVEL_VAR: job
          STEP_LEVEL_VAR: step1
#matrix is used to run the same job on multiple OS and images
# It is useful for testing the same code on different environments.
# It is also useful for running the same code on different versions of the same OS. 
#exclude is used to exclude a specific combination of OS and image from the matrix.
#fail-fast is used to stop the job if any step fails.
#fail-fast is useful for speeding up the workflow by not running unnecessary steps.
#max-parallel is used to limit the number of jobs that can run in parallel.
        # strategy:
        #   fail-fast: true
        #   max-parallel: 2
        #   matrix:
        #     os: [ubuntu-latest, Ubuntu 22.04]
        #     images: [hello-world, alpine]
        #     exclude:
        #       - os: [ubuntu-latest, Ubuntu 22.04]
        #         images: hello-world
        steps:
            - name: Download the Artifact
              uses: actions/download-artifact@v4
              with:
                name: Piglet
            - name: Read the Artifact
              if: ${{ success() }}
              #This will run the step only if the previous step was successful.
              
              env:
                STEP_LEVEL_VAR: step
              run: |
                cat abc.txt
                echo ${{ env.STEP_LEVEL_VAR }}
                echo ${{ env.JOB_LEVEL_VAR }}
                echo ${{ env.WORKFLOW_LEVEL }}
                echo $STEP_LEVEL_VAR
                echo $JOB_LEVEL_VAR
                echo $WORKFLOW_LEVEL
                echo ${{ vars.REPO_LVL_VAR }}
                docker --version
                docker info
                docker run ${{ matrix.images }}








